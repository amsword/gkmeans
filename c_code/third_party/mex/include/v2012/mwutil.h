/*
 * @(#)mwutil.h    generated by: makeheader 5.1.5  Thu Dec 29 01:02:12 2011
 *
 *		built from:	../../src/include/copyright.h
 *				../../src/include/pragma_interface.h
 *				cputime.cpp
 *				cycles.cpp
 *				dconvert.cpp
 *				demangle.cpp
 *				dynload.cpp
 *				emptystr.cpp
 *				enum_str.cpp
 *				expmatch.cpp
 *				f2cstr.cpp
 *				fgets.cpp
 *				filelink.cpp
 *				format.cpp
 *				fp_conv.cpp
 *				fpu.cpp
 *				getcwd.cpp
 *				hash.cpp
 *				incrfcn.cpp
 *				int_conv.cpp
 *				logfile.cpp
 *				lower.cpp
 *				multibyte.cpp
 *				mwclasses.cpp
 *				perfcount.cpp
 *				printf.cpp
 *				purifytools.cpp
 *				set.cpp
 *				special_nans.cpp
 *				stacktrc.cpp
 *				strcat.cpp
 *				strcmp.cpp
 *				strcmpi.cpp
 *				strcpy.cpp
 *				strdup.cpp
 *				strlen.cpp
 *				strrep.cpp
 *				strrstr.cpp
 *				strtok.cpp
 *				sysinfo.cpp
 *				timeinfo.cpp
 *				tmpnam.cpp
 *				tolower.cpp
 *				upper.cpp
 *				ut_alloca.cpp
 *				utassert.cpp
 *				utcrc.cpp
 *				utsignal.cpp
 *				wallclok.cpp
 *				array/array.cpp
 *				basic/basic_contexts.cpp
 *				checksum/md5checksum.cpp
 *				coll/functional.cpp
 *				coll/hash_map.cpp
 *				coll/hashrank.cpp
 *				cpputils/attacher.cpp
 *				cpputils/chunkedptr.cpp
 *				cpputils/countlist.cpp
 *				cpputils/safepointer.cpp
 *				cpputils/stat_ref_ok.cpp
 *				cpputils/stl_allocator.cpp
 *				dsbuffer/dsbuffer.cpp
 *				dtoa/dtoa.cpp
 *				dtoa/fpc.cpp
 *				dtoa/g_fmt.cpp
 *				err/error_context.cpp
 *				except/cmnHooks.cpp
 *				except/cmnSystemCalls.cpp
 *				except/errInternalException.cpp
 *				except/errSystemError.cpp
 *				except/errThrowable.cpp
 *				except/errUserException.cpp
 *				except/exceptCleanup.cpp
 *				except/exceptTypedefs.cpp
 *				except/instCpuCounter.cpp
 *				except/instInstrument.cpp
 *				except/instStopwatch.cpp
 *				except/logBasicSystemHandler.cpp
 *				except/logDataOutput.cpp
 *				except/logDebugOutputHandler.cpp
 *				except/logExternalizable.cpp
 *				except/logFilter.cpp
 *				except/logFormattable.cpp
 *				except/logFormatter.cpp
 *				except/logHandler.cpp
 *				except/logLevel.cpp
 *				except/logLogger.cpp
 *				except/logObjectOutput.cpp
 *				except/logObjectOutputStream.cpp
 *				except/logOutputStreamHandler.cpp
 *				except/logStreamHandler.cpp
 *				except/logTerminalHandler.cpp
 *				except/logXmlFormatter.cpp
 *				except/msgMsgCodeException.cpp
 *				except/msgMsgFormat.cpp
 *				except/usrReport.cpp
 *				except/usrRunning.cpp
 *				except/usrStartup.cpp
 *				except/usrStrategy.cpp
 *				ghash/ghash.cpp
 *				gtable/gtable.cpp
 *				hashtool/hashtool.cpp
 *				icuext/uchar.cpp
 *				icuext/uconv.cpp
 *				icuext/uctype.cpp
 *				icuext/uerror.cpp
 *				icuext/uhash.cpp
 *				icuext/umisc.cpp
 *				icuext/urecognize.cpp
 *				icuext/uspecial.cpp
 *				icuext/ustdio.cpp
 *				icuext/ustring.cpp
 *				icuext/utf.cpp
 *				icuext/utf8str.cpp
 *				ihash/ihash.cpp
 *				interval/fsi.cpp
 *				lcctype/utctype.cpp
 *				linebuf/linebuf.cpp
 *				mem/memory_context.cpp
 *				memmgr/memalloc.cpp
 *				msg/message_context.cpp
 *				nh/namehash.cpp
 *				nh/symtab.cpp
 *				profile/profile.cpp
 *				regexp/re_api.cpp
 *				regexp/re_builder.cpp
 *				regexp/re_collection.cpp
 *				regexp/re_context.cpp
 *				regexp/re_evaluator.cpp
 *				regexp/re_flags.cpp
 *				regexp/re_memory.cpp
 *				regexp/re_node_factory.cpp
 *				regexp/re_parser.cpp
 *				regexp/re_parser_context.cpp
 *				regexp/re_private_nodes.cpp
 *				regexp/re_protected_nodes.cpp
 *				regexp/re_replace.cpp
 *				regexp/re_replace_nodes.cpp
 *				regexp/re_replace_parser.cpp
 *				regexp/re_replaceable.cpp
 *				regexp/re_results.cpp
 *				regexp/re_search_info.cpp
 *				regexp/re_token_info.cpp
 *				regexp/re_translate.cpp
 *				regexp/re_tree.cpp
 *				regexp/re_tree_parser.cpp
 *				regexp/re_util.cpp
 *				sort/qsort.cpp
 *				strbuf/string_buffer.cpp
 *				threads/atomic.cpp
 *				threads/mwatomic.cpp
 *				threads/mwbarrier.cpp
 *				threads/mwconcurrent.cpp
 *				threads/mwcondition.cpp
 *				threads/mwcountedbody.cpp
 *				threads/mwcountedpointer.cpp
 *				threads/mwevent.cpp
 *				threads/mwmonitor.cpp
 *				threads/mwmutex_lwm.cpp
 *				threads/mwmutexlock.cpp
 *				threads/mwobjmgr.cpp
 *				threads/mwpointer.cpp
 *				threads/mwrcrsvmtx.cpp
 *				threads/mwsemaphore.cpp
 *				threads/mwsingleton.cpp
 *				threads/mwthdspc.cpp
 *				threads/mwthread.cpp
 *				threads/mwthreadid.cpp
 *				threads/mwtimeunit.cpp
 *				threads/ut_thread.cpp
 *				tse/tse.cpp
 *				warn/warning_context.cpp
 *				warn/warnmgr.cpp
 */

#if defined(_MSC_VER)
# pragma once
#endif
#if defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 3))
# pragma once
#endif

#ifndef mwutil_h
#define mwutil_h


/*
 * Copyright 1984-2003 The MathWorks, Inc.
 * All Rights Reserved.
 */



/* Copyright 2003-2006 The MathWorks, Inc. */

/* Only define EXTERN_C if it hasn't been defined already. This allows
 * individual modules to have more control over managing their exports.
 */
#ifndef EXTERN_C

#ifdef __cplusplus
  #define EXTERN_C extern "C"
#else
  #define EXTERN_C extern
#endif

#endif


/*
 * load library into memory
 */
EXTERN_C void *utLoadLibrary(
    const char	*fullname,	/* _full_ library path name */
    int		*errorStatus	/* return variable for error code */
    );


/*
 * Check whether shared library is loaded without loading it
 * Takes basename. Returns true if the library is loaded 
 */
EXTERN_C bool utIsLibraryLoaded(const char *name);


/*
 * Return handle for already loaded library
 */
EXTERN_C void *utLoadModule(const char *basename);


/*
 * lookup symbol in a loaded library
 */
EXTERN_C void *utFindSymbolInLibrary(
    void        *handle,	/* handle returned by utLoadLibrary */
    const char  *symbol         /* symbol name to look up */
    );


/*
 * unload a previously loaded library
 */
EXTERN_C int utUnloadLibrary(
    void        *handle		/* handle returned by utLoadLibrary */
    );


/*
 * Retrieve last error in dynamic loader utility routines
 */
EXTERN_C const char *utLastLibraryError(void);


/*
 * Predicate to determine whether a double is an int.
 * -0 is not considered an int, because converting it back
 * does not yield the same double.
 */
EXTERN_C bool utDblIsInt(double x);




/*
 * Use unique NaNs as flags for special values
 * These values should never be generated by Matlab as valid NaNs.
 *
 * The low-order word is all zeros.
 */

#define UT_SPECIAL_NAN 0x7ff5c5c0

#define UT_NAN_NEVER_TOUCHED (UT_SPECIAL_NAN + 0x1)
#define UT_NAN_FORLOOP_EMPTY (UT_SPECIAL_NAN + 0x2)


#define UT_SET_NAN_VALUE(lval, jqnan) ut_SET_BOTH(lval, jqnan, 0)

/*
 * since the x86 fpu can change the leading mastissa bit on QNaNs, we check for
 * equality with and without the bit set.
 */
#define UT_QNAN_BITMASK 0x00080000
#define UT_IS_NAN_VALUE(val, jqnan)                                                                     \
    (*(((int*)&(val))+(CPU_NUM_FORMAT==FIEEE_BE)) == 0x0 &&                                             \
     (*(((int*)&(val))+(CPU_NUM_FORMAT==FIEEE_LE))|UT_QNAN_BITMASK) == ((jqnan)|UT_QNAN_BITMASK))



#endif /* mwutil_h */
